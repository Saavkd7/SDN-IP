from mininet.net import Mininet
from mininet.node import RemoteController
from mininet.cli import CLI
from mininet.log import setLogLevel
from mininet.topo import Topo
from abilene_topo import Abilene
from mininet.link import TCLink
import traffic_injector
import time
import os  # Added to handle folder operations

class Topology(Topo):
    def __init__(self, *args, **params):
        super().__init__(*args, **params)
        topo = Abilene()
        switches = {}
        for i in topo.city_names:
            dpid_int = topo.citiesID[i]
            dpid_hex = "{:016x}".format(dpid_int)
            switches[i] = self.addSwitch(i, dpid=dpid_hex, protocols='OpenFlow13')
            h = self.addHost(f'h_{i}')
            self.addLink(h, switches[i], bw=1000, delay='0ms')
        
        for u, v, bw, delay in topo.links:
            self.addLink(switches[u], switches[v], delay=delay)

def run_network():
    topo = Topology()
    net = Mininet(topo=topo, controller=RemoteController, link=TCLink, waitConnected=True)
    net.start()
    print("Network Started")
    print("Waiting for controller...")
    time.sleep(2)
    
    print("*** CONFIGURING QoS (The Ambulance Lane) ***")
    for switch in net.switches:
        for intf in switch.intfList():
            if intf.name == 'lo': continue 
            
            cmd_qos = (
                f"ovs-vsctl set port {intf.name} qos=@newqos -- "
                f"--id=@newqos create qos type=linux-htb other-config:max-rate=1000000000 queues:0=@q0 queues:1=@q1 -- "
                f"--id=@q0 create queue other-config:min-rate=10000000 other-config:max-rate=200000000 other-config:burst=100000 -- "
                f"--id=@q1 create queue other-config:min-rate=100000000 other-config:max-rate=1000000000 other-config:burst=100000"
            )
            switch.cmd(cmd_qos)
            
            cmd_filter = f"tc filter add dev {intf.name} parent 1: protocol all prio 1 u32 match u16 0x88cc 0xffff at 12 flowid 1:2"
            switch.cmd(cmd_filter)

    print("*** QoS Configured: LLDP prioritized via Kernel Filter ***")
    
    print("Waiting for LLDP discovery (15s)...")
    time.sleep(15) 
    net.pingAll() 
    print("[!] Warmup complete. Topology is ready.\n")
    
    print("\n--- READY TO INJECT TRAFFIC ---")
    
    # --- CHANGED SECTION START ---
    answer = input("Do you want to run the Traffic Matrices from a folder? (y/n): ")
    if answer.lower() == 'y':
        folder_path = input("Enter the path to the folder containing traffic matrices (e.g., ./data): ").strip()
        
        if os.path.isdir(folder_path):
            # 1. Get all files ending in .dat (or your specific extension)
            files = [f for f in os.listdir(folder_path) if f.endswith('.dat')]
            
            # 2. Sort them to ensure time-series order (Crucial!)
            files.sort()
            
            print(f"Found {len(files)} traffic matrix files. Starting injection sequence...")
            
            for index, filename in enumerate(files):
                full_path = os.path.join(folder_path, filename)
                print(f"\n[{index+1}/{len(files)}] Processing: {filename}")
                
                # ðŸ”¥ FIX: Tiny traffic load to prevent CPU Crash
                # Note: Processing 40k files with 30s duration each will take weeks.
                # You might want to lower 'duration' for testing.
                flows = traffic_injector.parse_traffic_matrix(full_path, scaling_factor=0.05)
                
                # Run this traffic matrix
                traffic_injector.inject_traffic(net, flows, duration=30)
                
                # Optional: Add a small pause between matrices if needed
                # time.sleep(1) 
        else:
            print(f"Error: The folder '{folder_path}' does not exist.")
    # --- CHANGED SECTION END ---
    
    print("Network is ready. Type exit to stop.")
    CLI(net)
    net.stop() 

if __name__== '__main__':
    setLogLevel('info')
    run_network()
